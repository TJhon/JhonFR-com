{
  "hash": "c390071b97d31508b24a6fdd11890f66",
  "result": {
    "markdown": "---\ntitle: \"Ssytndid\"\ndescription: \"Adaptation of the synthdid package for staggered adoptions, improving the implementation of the model in different contexts.\"\nimage: synthdid.png\nimage-width: 90%\ndate: 2023-05-07\ncategories: \n  - Project\n  - R package\n  - Synthdid\n  - SSynthdid \ntags: \n  - R\n  - R package\n  - RStudio\npage: project\n---\n\n\n# The `synthdid` package - [Link](https://github.com/synth-inference/synthdid)\n\nThis package implements the synthetic difference in difference estimator (SDID) for the average treatment effect in panel data, as proposed in Arkhangelsky et al (2019).\n\n\n\n## Basic Usage\n\n\nThis library suggests the following steps: pass the database through the `panel.matrices()` function, which returns a list. The elements of the list are then passed through the `synthdid_estimate(Y, N0, T0)` function. If we want to introduce covariates, we need to take several additional steps. Here, I will simulate data from `1:nrow()` to observe the entire procedure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"synth-inference/synthdid\")\nlibrary(synthdid)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\nLet's observe the `califonia_prop99` database, which is a `data.frame`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(california_prop99) # NOt a tibble\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        State Year PacksPerCapita treated\n1     Alabama 1970           89.8       0\n2    Arkansas 1970          100.3       0\n3    Colorado 1970          124.8       0\n4 Connecticut 1970          120.0       0\n5    Delaware 1970          155.0       0\n6     Georgia 1970          109.9       0\n```\n:::\n:::\n\n\nNow, we pass it through the function and obtain the estimated value of the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Estimate the effect of California Proposition 99 on cigarette consumption\nsetup = panel.matrices(california_prop99)\ntau.hat = synthdid_estimate(setup$Y, setup$N0, setup$T0)\ntau.hat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsynthdid: -15.604 +- NA. Effective N0/N0 = 16.4/38~0.4. Effective T0/T0 = 2.8/19~0.1. N1,T1 = 1,12. \n```\n:::\n:::\n\n\n## Problems\n\nEverything is fine, but this library has some issues:\n  - Only works with `data.frames`.\n  - Doesn't yet work for staggered data.\n  - Adding covariates to the model means increasing the steps through intermediate functions to create the model.\n\n### Only works with `data.frames`.\n\nIf we pass a `tibble`, we will encounter an error when using the `panel.matrices` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalifornia_df <- as_tibble(california_prop99) \nhead(california_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  State        Year PacksPerCapita treated\n  <fct>       <int>          <dbl>   <int>\n1 Alabama      1970           89.8       0\n2 Arkansas     1970          100.        0\n3 Colorado     1970          125.        0\n4 Connecticut  1970          120         0\n5 Delaware     1970          155         0\n6 Georgia      1970          110.        0\n```\n:::\n:::\n\n\nTo estimate, we would have to convert it to a `data.frame` (See Staggered Synthdid). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetup <- panel.matrices(california_df, \"State\", \"Year\", \"PacksPerCapita\", \"treated\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in panel.matrices(california_df, \"State\", \"Year\", \"PacksPerCapita\", : There is no variation in treatment status.\n```\n:::\n:::\n\n\n### Staggered Synthdid\n\nIn this case, we are using the `quota` database.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquota_dta <- \"https://www.damianclarke.net/stata/quota_example.dta\"\nquota_df <- quota_dta |> haven::read_dta()\nhead(quota_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  womparl lnmmrt country  year quota lngdp\n    <dbl>  <dbl> <chr>   <dbl> <dbl> <dbl>\n1   28.8    4.26 Albania  1990     0  8.46\n2    3.60   4.23 Albania  1991     0  8.12\n3    5.70   4.17 Albania  1992     0  8.05\n4    5.70   4.14 Albania  1993     0  8.14\n5    5.70   3.89 Albania  1994     0  8.23\n6    5.70   3.97 Albania  1995     0  8.36\n```\n:::\n:::\n\n\nIf we want to perform the estimation (see here the procedures for estimating a `tibble`), we will encounter an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npanel.matrices(quota_df, unit = \"country\", time = \"year\", outcome = \"womparl\", treatment = \"quota\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in panel.matrices(quota_df, unit = \"country\", time = \"year\", outcome = \"womparl\", : There is no variation in treatment status.\n```\n:::\n\n```{.r .cell-code}\nquota_df1 <- as.data.frame(quota_df)\npanel.matrices(quota_df1, unit = \"country\", time = \"year\", outcome = \"womparl\", treatment = \"quota\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n\nWarning in FUN(newX[, i], ...): coercing argument of type 'double' to logical\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in panel.matrices(quota_df1, unit = \"country\", time = \"year\", outcome = \"womparl\", : The package cannot use this data. Treatment adoption is not simultaneous.\n```\n:::\n:::\n\n\n\n### Adding Covariates\n\nFinally, adding covariates to the model means increasing the steps through intermediate functions to create the model. In the case of a `tibble`, we have to convert it to a **wide data** format and transform it into a 3-dimensional matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalifornia_prop99_cov <- mutate(california_prop99, cov = 1:n())\nx_cov <- california_prop99_cov |> dplyr::select(1, 2, cov) |> \n  pivot_wider(names_from = \"Year\", values_from = \"cov\") |> \n  dplyr::select(!State) |> \n  as.matrix() |> \n  abind::abind(along = 3)\ndim(x_cov)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 39 31  1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsetup <- panel.matrices(california_prop99, \"State\", \"Year\", \"PacksPerCapita\", \"treated\")\nsynthdid::synthdid_estimate(\n    Y = setup$Y, \n    N0 = setup$N0, \n    T0 = setup$T0,\n    X = x_cov\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsynthdid: -15.610 +- NA. Effective N0/N0 = 16.4/38~0.4. Effective T0/T0 = 2.8/19~0.1. N1,T1 = 1,12. \n```\n:::\n:::\n\n\n\n# The Staggered Synthdid (`Ssynthdid`) - [Link](https://github.com/TJhon/ssynthdid)\n\nTo solve this problem, the original package was adapted. The functions remain the same, with a small modification: before each function from the original package, there is an additional \"s\" at the beginning. In this case, we avoid passing the database through an auxiliary function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"tjhon/synthdid\")\nlibrary(ssynthdid)\n```\n:::\n\n\n### `tibbles` y `data.frames`\n\nFor the first problem, let's consider that we have a `tibble` and a `data.frame.` If we pass them through the function, we obtain the same results in both cases, and the estimated value is identical to that of the original package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(california_df); class(california_prop99)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nssynth_estimate(california_df, \"State\", \"Year\", \"treated\", \"PacksPerCapita\") |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ att_estimate: num -15.6\n $ att_table   : tibble [1 × 11] (S3: tbl_df/tbl/data.frame)\n  ..$ time        : int 1989\n  ..$ tau         : num -15.6\n  ..$ tau_wt      : num 12\n  ..$ weighted_tau: num -15.6\n  ..$ N0          : int 38\n  ..$ T0          : num 19\n  ..$ N1          : int 1\n  ..$ T1          : num 12\n  ..$ weights_sdid:List of 1\n  ..$ Y_beta      :List of 1\n  ..$ Units       :List of 1\n $ data_ref    : tibble [1,209 × 7] (S3: tbl_df/tbl/data.frame)\n  ..$ unit     : Factor w/ 39 levels \"Alabama\",\"Arkansas\",..: 1 2 4 5 6 7 8 9 10 11 ...\n  ..$ time     : int [1:1209] 1970 1970 1970 1970 1970 1970 1970 1970 1970 1970 ...\n  ..$ treatment: int [1:1209] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ outcome  : num [1:1209] 89.8 100.3 124.8 120 155 ...\n  ..$ treated  : int [1:1209] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ ty       : int [1:1209] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ tyear    : int [1:1209] 0 0 0 0 0 0 0 0 0 0 ...\n```\n:::\n\n```{.r .cell-code}\nssynth_estimate(california_prop99, \"State\", \"Year\", \"treated\", \"PacksPerCapita\") |> glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 3\n $ att_estimate: num -15.6\n $ att_table   : tibble [1 × 11] (S3: tbl_df/tbl/data.frame)\n  ..$ time        : int 1989\n  ..$ tau         : num -15.6\n  ..$ tau_wt      : num 12\n  ..$ weighted_tau: num -15.6\n  ..$ N0          : int 38\n  ..$ T0          : num 19\n  ..$ N1          : int 1\n  ..$ T1          : num 12\n  ..$ weights_sdid:List of 1\n  ..$ Y_beta      :List of 1\n  ..$ Units       :List of 1\n $ data_ref    : tibble [1,209 × 7] (S3: tbl_df/tbl/data.frame)\n  ..$ unit     : Factor w/ 39 levels \"Alabama\",\"Arkansas\",..: 1 2 4 5 6 7 8 9 10 11 ...\n  ..$ time     : int [1:1209] 1970 1970 1970 1970 1970 1970 1970 1970 1970 1970 ...\n  ..$ treatment: int [1:1209] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ outcome  : num [1:1209] 89.8 100.3 124.8 120 155 ...\n  ..$ treated  : int [1:1209] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ ty       : int [1:1209] 0 0 0 0 0 0 0 0 0 0 ...\n  ..$ tyear    : int [1:1209] 0 0 0 0 0 0 0 0 0 0 ...\n```\n:::\n:::\n\n\n\n### Staggered Synthdid\n\nFor the second problem, we will use the quota database and the `ssynthdid_estimate` function. This function takes care of finding the breakpoint, returns the estimated value for staggered adoptions, and stores the information in a `tibble.` The `tibble` contains information about the estimated value for each breakpoint, along with additional information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquota_dta <- \"https://www.damianclarke.net/stata/quota_example.dta\"\nquota_df <- quota_dta |> haven::read_dta()\nssynth_estimate(quota_df, unit = \"country\", time = \"year\", outcome = \"womparl\", treated = \"quota\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$att_estimate\n[1] 8.034102\n\n$att_table\n# A tibble: 7 × 11\n   time    tau tau_wt weighted_tau    N0    T0    N1    T1 weights_sdid Y_beta  \n  <dbl>  <dbl>  <dbl>        <dbl> <int> <dbl> <int> <dbl> <list>       <list>  \n1  2000  8.39      16       1.43     110    10     1    16 <named list> <dbl[…]>\n2  2002  6.97      28       2.08     110    12     2    14 <named list> <dbl[…]>\n3  2003 14.0       26       3.86     110    13     2    13 <named list> <dbl[…]>\n4  2005 -3.45      11      -0.404    110    15     1    11 <named list> <dbl[…]>\n5  2010  2.75       6       0.175    110    20     1     6 <named list> <dbl[…]>\n6  2012 21.8        4       0.926    110    22     1     4 <named list> <dbl[…]>\n7  2013 -0.820      3      -0.0262   110    23     1     3 <named list> <dbl[…]>\n# ℹ 1 more variable: Units <list>\n\n$data_ref\n# A tibble: 3,094 × 7\n   unit          time treatment outcome treated    ty tyear\n   <chr>        <dbl>     <dbl>   <dbl>   <dbl> <dbl> <dbl>\n 1 Albania       1990         0   28.8        0     0     0\n 2 Angola        1990         0   14.5        0     0     0\n 3 Argentina     1990         0    6.30       0     0     0\n 4 Armenia       1990         0   35.6        0     0     0\n 5 Australia     1990         0    6.10       0     0     0\n 6 Austria       1990         0   11.5        0     0     0\n 7 Bahamas, The  1990         0    4.10       0     0     0\n 8 Barbados      1990         0    3.70       0     0     0\n 9 Belgium       1990         0    8.5        0     0     0\n10 Belize        1990         0    0          0     0     0\n# ℹ 3,084 more rows\n```\n:::\n:::\n\n\n### Adding Covariates\n\n\nFinally, to estimate the model with covariates, we only need to include the `covariates` parameter in `ssynth_estimate(..., covariates = c(...))`. Note that it should be a vector, so even if it's a single element, it should be specified within `c()`. One last detail is that the columns of covariates should not have any `NA` values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nssynth_estimate(california_prop99_cov, \"State\", \"Year\", \"treated\", \"PacksPerCapita\", covariates = c(\"cov\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$att_estimate\n[1] -15.60991\n\n$att_table\n# A tibble: 1 × 11\n   time   tau tau_wt weighted_tau    N0    T0    N1    T1 weights_sdid Y_beta  \n  <int> <dbl>  <dbl>        <dbl> <int> <dbl> <int> <dbl> <list>       <list>  \n1  1989 -15.6     12        -15.6    38    19     1    12 <named list> <dbl[…]>\n# ℹ 1 more variable: Units <list>\n\n$data_ref\n# A tibble: 1,209 × 8\n   unit         time treatment outcome treated    ty tyear   cov\n   <fct>       <int>     <int>   <dbl>   <int> <int> <int> <int>\n 1 Alabama      1970         0    89.8       0     0     0     1\n 2 Arkansas     1970         0   100.        0     0     0     2\n 3 Colorado     1970         0   125.        0     0     0     3\n 4 Connecticut  1970         0   120         0     0     0     4\n 5 Delaware     1970         0   155         0     0     0     5\n 6 Georgia      1970         0   110.        0     0     0     6\n 7 Idaho        1970         0   102.        0     0     0     7\n 8 Illinois     1970         0   125.        0     0     0     8\n 9 Indiana      1970         0   135.        0     0     0     9\n10 Iowa         1970         0   108.        0     0     0    10\n# ℹ 1,199 more rows\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}